#include <iostream>
#include "matrix.h"

const int num_inputs = 2;
const int num_outputs = 2;
const int num_states = 4;

//this is some complex code written by Austin Schuh which was made obsolete
//by the use of a different matrix library, but was kept because it
//represents a lot of work and could possibly be recycled in the future

/*

MatrixXd s2z_A(MatrixXd A, MatrixXd B, double dt)
{
	ComplexEigenSolver<MatrixXd> eigensolver(A);

	Matrix<std::complex<double>, num_states, num_states> diag(num_states, num_states);
	Matrix<std::complex<double>, num_states, num_states> diage(num_states, num_states);
	ComplexEigenSolver<MatrixXd>::EigenvalueType eval = eigensolver.eigenvalues();
	for (int j = 0; j < num_states; j ++) {
		for (int i = 0; i < num_states; i ++) {
			diag(i, j) = 0.0;
			diage(i, j) = 0.0;
		}
	}
	for (int i = 0; i < num_states; i ++) {
		std::complex<double> lambda = eval(i, 0);
		diag(i, i) = std::exp(lambda * dt);
		if (std::abs(lambda) < 1.0e-14) {
			diag(i, i) = dt;
		} else {
			diag(i, i) = (std::exp(lambda * dt) - 1.0) / lambda;
		}
	}

	Matrix<std::complex<double>, num_states, num_states> dmy = (eigensolver.eigenvectors() * diag * eigensolver.eigenvectors().inverse());
	MatrixXd ans(num_states, num_states);
	for (int j = 0; j < num_states; j ++) {
		for (int i = 0; i < num_states; i ++) {
			ans(i, j) = std::real(dmy(i, j));
		}
	}
	return ans;
}
MatrixXd s2z_B(MatrixXd A, MatrixXd B, double dt)
{
	ComplexEigenSolver<MatrixXd> eigensolver(A);

	Matrix<std::complex<double>, num_states, num_states> diag(num_states, num_states);
	Matrix<std::complex<double>, num_states, num_states> diage(num_states, num_states);
	ComplexEigenSolver<MatrixXd>::EigenvalueType eval = eigensolver.eigenvalues();
	for (int j = 0; j < num_states; j ++) {
		for (int i = 0; i < num_states; i ++) {
			diag(i, j) = 0.0;
			diage(i, j) = 0.0;
		}
	}
	for (int i = 0; i < num_states; i ++) {
		std::complex<double> lambda = eval(i, 0);
		diag(i, i) = std::exp(lambda * dt);
		if (std::abs(lambda) < 1.0e-14) {
			diag(i, i) = dt;
		} else {
			diag(i, i) = (std::exp(lambda * dt) - 1.0) / lambda;
		}
	}

	Matrix<std::complex<double>, num_states, num_states> dmy = (eigensolver.eigenvectors() * diage * eigensolver.eigenvectors().inverse());
	MatrixXd ans(num_states, num_states);
	for (int j = 0; j < num_states; j ++) {
		for (int i = 0; i < num_states; i ++) {
			ans(i, j) = std::real(dmy(i, j));
		}
	}
	return ans;
}
*/

/**
  * A state space controller
  * After being set up properly, this controller works as such:
  * Given two matrices:
  *     r: the robot's goal position and velocity
  *     y: the robot's current left and right encoder values
  * The controller will return a left and right voltage (with 12V being the
  * maximum voltage) to make the robot behave as well as possible
  */
class ss_controller
{
	private:
	    const int num_inputs;
	    const int num_outputs;
	    const int num_states;

	    //the state matrices, calculated and imported from matlab
	    struct matrix *A;
	    struct matrix *C;
	    struct matrix *L;
	    struct matrix *B;
	    struct matrix *D;
	    struct matrix *K;

	    //temporary matrices needed because of the C-style matrix lib
	    struct matrix *xhat_a;
	    struct matrix *xhat_b;
	    struct matrix *xhat_l;

	    struct matrix *outmat_r;
	    struct matrix *outmat_xhat;

	    //precompued matrices generated by matlab
	    struct matrix *A_precomp;
	    struct matrix *Br_precomp;

	public:
		struct matrix *xhat;
	public:
		ss_controller() :
			num_inputs(2),
			num_outputs(2),
			num_states(4)
		{
			//initalizes all the matrices
			A = init_matrix(num_states, num_states);
			C = init_matrix(num_outputs, num_states);
			L = init_matrix(num_states, num_outputs);
			B = init_matrix(num_states, num_inputs);
			D = init_matrix(num_outputs, num_inputs);
			K = init_matrix(num_inputs, num_states);
			xhat = init_matrix(num_states, 1);
			A_precomp = init_matrix(num_states, num_states);
			Br_precomp = init_matrix(num_states, num_states);
			xhat = init_matrix(num_states, 1);
			xhat_a = init_matrix(num_states, 1);
			xhat_b = init_matrix(num_states, 1);
			xhat_l = init_matrix(num_states, 1);
			outmat_r = init_matrix(num_outputs, 1);
			outmat_xhat = init_matrix(num_outputs, 1);

			//import the matlab-computed matrix values
			#include "controller.h"

			//A_precomp = A - (L * C) - (B * K);
			//Br_precomp = B * K;
		}
		
		void reset()
		{
			xhat = init_matrix(num_states, 1);
			for (int i = 0; i < num_states; i ++) {
				matrix_set(xhat,i,0,0.0);
			}
		}
		~ss_controller() {
                    free_matrix(A);
                    free_matrix(C);
                    free_matrix(L);
                    free_matrix(B);
                    free_matrix(D);
                    free_matrix(K);
                    free_matrix(xhat_a);
                    free_matrix(xhat_b);
                    free_matrix(xhat_l);
                    free_matrix(xhat);
                    free_matrix(A_precomp);
                    free_matrix(Br_precomp);
                    free(outmat_r);
                    free(outmat_xhat);
		}

		/**
		  * The heart of the state space controller
		  * @param outmat the output matrix of left and right
		  * voltages
		  * @param r the r matrix, which holds the goal left
		  * and right positions and velocities
		  * @param y the current left and right distances
		  */
		void update(struct matrix *outmat, struct matrix *r, struct matrix *y)
		{
			//(ebakan): C-style computations = FFFFFFFFFFFFFUUUUUUU
			//MatrixXd nxhat = (A_precomp * xhat) + (Br_precomp * r) + (L * y);

			//compute xhat stuff
			matrix_mult(xhat_a, A_precomp, xhat);
			matrix_mult(xhat_b, Br_precomp, r);
			matrix_mult(xhat_l, L, y);

			matrix_add(xhat,xhat_a,xhat_b);
			matrix_add(xhat,xhat,xhat_l);

			//return K * r - K * xhat;

			matrix_mult(outmat_r, K, r);
			matrix_mult(outmat_xhat, K, xhat);
			matrix_minus(outmat, outmat_r, outmat_xhat);
		}
		
};


/*
int main()
{
	MatrixXd y(2, 1);
	MatrixXd r(4, 1);
	ss_controller ssc;

	y << 1.0, 1.0;
	r << 0.0, 0.0, 0.0, 0.0;

	std::cout << ssc.update(r, y) << std::endl;
}
*/

