//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutoProgramBase.cpp
//  @ Date : 2/8/2009
//  @ Author : 
//
//

#include <math.h>

#include "WsAutoProgramBase.h"
#include "WsAutoNStepBase.h"
#include "WsDriveVector.h"
#include "WsDriveBase6WD.h"
#include "WsLarm.h"
#include "WsEncoder.h"
#include "Timer.h"
#include "WsPid.h"
#include "WsCalibration.h"

float WsAutoProgramBase::convertDelay(StartDelayT delay)
{
  // THIS ASSUMES THAT THE PROGRAM IS AN N STEP BASE....IF WE ADD MORE TYPES WE
  // NEED TO UPDATE THIS TO PUSH THE DELAY LOGIC SOMEWHERE ELSE
  return WsAutoNStepBase::convertDelay(delay);
}

/**
* Constructs a WsAutoProgramBase.  Creates a stopped timer
*/
WsAutoProgramBase::WsAutoProgramBase()
{
    ap_driveBase = NULL;
    ap_larm = NULL;
    ap_calib = WsCalibration::getInstance();
    ap_timer = new Timer();
    if(ap_timer != NULL)
    {
        ap_timer->Stop();
    }
    a_timerStartFlag = true;
}

/**
* Destructs a WsAccumulator.  Cleans up the instantiated timer
*/
WsAutoProgramBase::~WsAutoProgramBase()
{
    if(ap_timer != NULL)
    {
        delete ap_timer;
    }
    ap_timer = NULL;
}

/**
* The default implementation of the run function that the WsAutonomousManager
* will call every iteration.  The default is to not move.
* @returns A boolean value representing whether the progam is done
*/
bool WsAutoProgramBase::run(void )
{
    bool done = true;
    turnOffDriveBase();
    turnOffAppendages();
    return done;
}

/**
* Assigns a drive base object to the class member
* @param p_driveBase The drive base to use
*/
void WsAutoProgramBase::assignDriveBase(WsDriveBase6WD* p_driveBase)
{
    ap_driveBase = p_driveBase;
}

void WsAutoProgramBase::assignAppendages(WsLarm* p_larm)
{
    ap_larm = p_larm;
}

void WsAutoProgramBase::setStartDelay(StartDelayT delay)
{
     a_startDelay = delay;
}

void WsAutoProgramBase::setTargetPeg(RackPositionT rackPosition,
                                     ColPositionT colPosition,
                                     PegHeightT pegHeight)
{
    a_rackPosition = rackPosition;
    a_colPosition = colPosition;
    a_pegHeight = pegHeight;
}

/**
* Turns off all drive base outputs.
*/
void WsAutoProgramBase::turnOffDriveBase(void )
{
    if(ap_driveBase != NULL)
    {
        ap_driveBase->setVector(0.0, 0.0, false, false);
    }
}

/**
* Turns off all appendage outputs.
*/
void WsAutoProgramBase::turnOffAppendages(void )
{
    setLarm( WsLarm::POSITION_NONE,
             WsRollerClaw::ROLLER_OFF,
             WsRollerClaw::CLAW_CLOSE);
}


/**
* A non-blocking delay function that returns true when it is called and the time has elapsed.
* The start flag is used to keep track of whether a timer is stopped and needs to be started again.
* @param delayTime How long to wait until the time is considered elapsed
* @param *p_currentTime Passed in by reference, it will be populated with the current timer value
* @returns A boolean value for whether the time has elapsed
*/
bool WsAutoProgramBase::delay(double delayTime, double* p_currentTime, bool forceStop)
{
    double time = 0;
    bool done = false;

    if(ap_timer != NULL)
    {
        if (a_timerStartFlag == true)
        {
            ap_timer->Reset();
            ap_timer->Start();
            a_timerStartFlag = false;
        }

        time = ap_timer->Get();

        if((forceStop == true) || (time > delayTime))
        {
            if(forceStop)
            {
                printf("FORCE ");
            }
            ap_timer->Stop();
            ap_timer->Reset();
            a_timerStartFlag = true;
            done = true;
        }

        *p_currentTime = time;
    }
    else
    {
        done = true;
    }

    printf("TIME: (%.2f, %.2f) ", delayTime, time);
    return done;
}

/**
* Set the drive output based on the input parameters
* @param p_driveVector The vector to drive at
*/
//void WsAutoProgramBase::setDrive(WsDriveVector* p_driveVector, WsDriveBase6WD::ShifterStateT shifterState)
void WsAutoProgramBase::setDrive(float throttle, float wheel, WsDriveBase6WD::ShifterStateT shifterState,
                                 bool useDriveStraight)
{

    if(ap_driveBase != NULL)
    {
        printf("DRIVE: (%4f, %4f %d) ", throttle, wheel, shifterState);
        ap_driveBase->setVector(-1 * throttle, -1 * wheel, useDriveStraight, shifterState == WsDriveBase6WD::SHIFT_STATE_LOW);
        ap_driveBase->setShifter(shifterState);
    }
}

void WsAutoProgramBase::setLarm( WsLarm::PositionT larmPosition,
                                 WsRollerClaw::RollerSpeedT rollerState,
                                 WsRollerClaw::ReleaseStateT releaseState)
{
    if(ap_larm != NULL)
    {
        //printf("LARM: (%d) ", larmPosition);
        ap_larm->setPosition(larmPosition);
        ap_larm->setRollerSpeed(rollerState);
        ap_larm->setClawReleaseState(releaseState);
    }
}

/**
* A non-blocking function that uses the input parameters to drive a certain way for a certain amount of time.
* @param p_driveVector The vector to drive at
* @param delayTime How long to wait until the time is considered elapsed
* @param *p_currentTime Passed in by reference, it will be populated with the current timer value
* @returns A boolean value for whether the time has elapsed
*/
bool WsAutoProgramBase::driveByTime(float throttle,
                                    float wheel,
                                    WsDriveBase6WD::ShifterStateT shifterState,
                                    WsLarm::PositionT larmPosition,
                                    bool waitForLarm,
                                    WsRollerClaw::RollerSpeedT rollerClawSpeed,
                                    WsRollerClaw::ReleaseStateT rollerClawRelease,
                                    double driveTime,
                                    double* p_currentTime)
{
    setDrive(throttle, wheel, shifterState, true);
    setLarm(larmPosition, rollerClawSpeed, rollerClawRelease);
    return delay(driveTime, p_currentTime);
}

/**
* A non-blocking function that coasts (i.e. turns drive motors off) at a certain crab angle for a certain amount of time
* @param delayTime How long to wait until the time is considered elapsed
* @param *p_currentTime Passed in by reference, it will be populated with the current timer value
* @returns A boolean value for whether the time has elapsed
*/
bool WsAutoProgramBase::coast(WsDriveBase6WD::ShifterStateT shifterState,
                              WsLarm::PositionT larmPosition,
                              bool waitForLarm,
                              WsRollerClaw::RollerSpeedT rollerClawSpeed,
                              WsRollerClaw::ReleaseStateT rollerClawRelease,
                              double delayTime,
                              double* p_currentTime)
{
    return driveByTime(0.0, 0.0, shifterState, larmPosition, waitForLarm, rollerClawSpeed, rollerClawRelease, delayTime, p_currentTime);
}

bool WsAutoProgramBase::driveByEncoder(float throttle,
                                       float wheel,
                                       WsDriveBase6WD::ShifterStateT shifterState,
                                       WsLarm::PositionT larmPosition,
                                       bool waitForLarm,
                                       WsRollerClaw::RollerSpeedT rollerClawSpeed,
                                       WsRollerClaw::ReleaseStateT rollerClawRelease,
                                       WsDriveBase6WD::EncoderLocationT encoderLoc,
                                       INT32 encoderTarget,
                                       bool useDriveStraight,
                                       double timeout,
                                       double* p_currentTime,
                                       bool reinit)
{
    bool done = false;

    WsEncoder* enc;
    INT32 encoderVal = 0;
    double time = 0;
    bool driveDone = false;
    bool larmDone = false;

    enc = ap_driveBase->getEncoder(encoderLoc);

    if(enc != NULL)
    {
        if(ap_timer != NULL)
        {
            if (a_timerStartFlag == true || reinit == true)
            {
                printf("REINIT ");
                enc->resetRelCount();
                enc->Start();

                ap_timer->Reset();
                ap_timer->Start();

                a_timerStartFlag = false;
            }

            time = ap_timer->Get();
            *p_currentTime = time;

            printf("Time %.3f ", time);
            if(time < timeout)
            {
                encoderVal = enc->getRelCount();
                printf("ETarg: %d  ECur: %d ", encoderTarget, encoderVal);

                if(encoderTarget >= 0)
                {
                    if(encoderVal >= encoderTarget)
                    {
                        printf("DONE POS ");
                        driveDone = true;
                    }
                }
                else
                {
                    if(encoderVal <= encoderTarget)
                    {
                        printf("DONE NEG ");
                        driveDone = true;
                    }
                }
            }
            else
            {
                printf("TIMEOUT ");
                ap_timer->Stop();
                ap_timer->Reset();
                driveDone = true;
            }
        }
        else
        {
            printf("NO TIMER ");
            driveDone = true;
        }

        if(driveDone == false)
        {
            printf(" D %4f %4f %d", throttle, wheel, shifterState);
            setDrive(throttle, wheel, shifterState, useDriveStraight);
        }
        else
        {
            printf(" S ");
            //enc->Stop();
            setDrive(0.0, 0.0, shifterState, false);
        }
    }
    else
    {
        printf("NO ENCODER ");
        driveDone = true;
    }

    setLarm(larmPosition, rollerClawSpeed, rollerClawRelease);
    if(waitForLarm == true && 
       larmPosition != WsLarm::POSITION_NONE)
    {
        larmDone = ap_larm->isInPosition();
    }
    else
    {
        larmDone = true;
    }

    done = driveDone && larmDone;

    if(done == true)
    {
        printf("STOP ");
        //WsDriveVector stopVector(0,0);
        //setDrive(&stopVector, shifterState);
        a_timerStartFlag = true;
    }

    return done;
}


bool WsAutoProgramBase::driveByDistancePid(float throttle,
        float wheel,
        WsDriveBase6WD::ShifterStateT shifterState,
        WsLarm::PositionT larmPosition,
        bool waitForLarm,
        WsRollerClaw::RollerSpeedT rollerClawSpeed,
        WsRollerClaw::ReleaseStateT rollerClawRelease,
        WsDriveBase6WD::EncoderLocationT encoderLoc,
        INT32 encoderTarget,
        WsPid* p_pid,
        bool shortCircuit,
        double timeout,
        double* p_currentTime,
        bool reinit)
{
    bool done = false;
    bool driveDone = false;
    bool larmDone = false;

    WsEncoder* enc;
    INT32 encoderVal = 0;
    double time = 0;

    enc = ap_driveBase->getEncoder(encoderLoc);

    if(enc != NULL)
    {
        if(ap_timer != NULL)
        {
            if (a_timerStartFlag == true || reinit == true)
            {
                enc->resetRelCount();
                enc->Start();

                p_pid->resetErrorSum();

                ap_timer->Reset();
                ap_timer->Start();

                a_timerStartFlag = false;
                a_pidMaxValue = fabs(throttle);
            }

            time = ap_timer->Get();
            *p_currentTime = time;

            printf("Time %.3f ", time);
            if(time < timeout)
            {
                encoderVal = enc->getRelCount();
                p_pid->setDesiredValue(encoderTarget);
                p_pid->setMaxOutput(a_pidMaxValue);
                throttle = p_pid->calcPid(encoderVal);

                //printf("ETarg: %d  ECur: %d Sp: %3f Sh: %d", encoderTarget, encoderVal, throttle, shifterState);
                printf("ETarg: %d  ECur: %d Sp: %3f ", encoderTarget, encoderVal, throttle);

                if(shortCircuit == true)
                {
                    if( ( encoderTarget > 0 ) && ( encoderVal >= encoderTarget ) )
                    {
                        driveDone = true;
                    }
                    else if( ( encoderTarget < 0 ) && ( encoderVal <= encoderTarget ) )
                    {
                        driveDone = true;
                    }
                    else if (p_pid->isDone() == true)
                    {
                        printf("DONE EPID ");
                        driveDone = true;
                    }
                }
                else if(p_pid->isDone() == true)
                {
                        printf("DONE EPID ");
                        driveDone = true;
                }

            }
            else
            {
                printf("TIMEOUT ");
                ap_timer->Stop();
                ap_timer->Reset();
                driveDone = true;
            }
        }
        else
        {
            printf("NO TIMER ");
            driveDone = true;
        }

        if(driveDone == false)
        {
            //printf(" P %4f %4f %d", p_driveVector->a_speed, p_driveVector->a_direction, shifterState);
            setDrive(throttle, wheel, shifterState, true);
        }
        else
        {
            printf(" S ");
            setDrive(0.0, 0.0, shifterState, false);
            //enc->Stop();
        }
    }
    else
    {
        printf("NO ENCODER ");
        driveDone = true;
    }

    setLarm(larmPosition, rollerClawSpeed, rollerClawRelease);
    if(waitForLarm == true && 
       larmPosition != WsLarm::POSITION_NONE)
    {
        larmDone = ap_larm->isInPosition();
    }
    else
    {
        larmDone = true;
    }
    //larmDone = true;

    printf("D: %d  L: %d ", driveDone, larmDone);
    done = driveDone && larmDone;

    if(done == true)
    {
        printf("STOP ");
        a_timerStartFlag = true;
    }

    return done;
}

// The vector should have its angle set to be the direction to turn when positive
// throttle is applied (typically +-90).  The vector's speed component will adjust by PID.
bool WsAutoProgramBase::rotateToAngle(float throttle,
                               float wheel,
                               WsDriveBase6WD::ShifterStateT shifterState,
                               WsLarm::PositionT larmPosition,
                               bool waitForLarm,
                               WsRollerClaw::RollerSpeedT rollerClawSpeed,
                               WsRollerClaw::ReleaseStateT rollerClawRelease,
                               INT32 desiredAngle,
                               WsPid* p_pid,
                               double timeout,
                               double* p_currentTime,
                               bool reinit)
{
    bool done = false;
    bool driveDone = false;
    bool larmDone = false;
    double time = 0;

    INT32 currentAngle = (int)(ap_driveBase->getGyroAngle() * 1000);
    desiredAngle *= 1000;

    if(ap_timer != NULL)
    {
        if (a_timerStartFlag == true || reinit == true)
        {
            p_pid->resetErrorSum();

            ap_driveBase->resetGyro();

            ap_timer->Reset();
            ap_timer->Start();

            a_timerStartFlag = false;
        }

        time = ap_timer->Get();
        *p_currentTime = time;

        printf("Time %.3f ", time);
        if(time < timeout)
        {
            wheel = p_pid->calcPid(currentAngle, desiredAngle);

            printf("ATarg: %d  ACur: %d Speed: %3f Shift: %d", desiredAngle, currentAngle, throttle, shifterState);

            if(p_pid->isDone() == true)
            {
                printf("DONE RPID ");
                driveDone = true;
            }
        }
        else
        {
            printf("TIMEOUT ");
            ap_timer->Stop();
            ap_timer->Reset();
            driveDone = true;
        }
    }
    else
    {
        printf("NO TIMER ");
        driveDone = true;
    }

    setLarm(larmPosition, rollerClawSpeed, rollerClawRelease);
    if(waitForLarm == true && 
       larmPosition != WsLarm::POSITION_NONE)
    {
        larmDone = ap_larm->isInPosition();
    }
    else
    {
        larmDone = true;
    }

    if(driveDone == false)
    {
        printf(" P %4f %4f %d", throttle, wheel, shifterState);
        setDrive(throttle, wheel, shifterState, true);
    }
    else
    {
        printf(" S ");
        //enc->Stop();
        setDrive(0.0, 0.0, shifterState, false);
    }

    done = driveDone && larmDone;

    if(done == true)
    {
        printf("STOP ");
        a_timerStartFlag = true;
    }

    return done;
}


