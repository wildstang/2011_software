//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutoSixStepBase.cpp
//  @ Date : 3/12/2009
//  @ Author : 
//
//


#include "Timer.h"
#include "WsAutoNStepBase.h"
#include "WsDriveBase6WD.h"
#include "WsDashboard.h"
#include "WsLarm.h"

//Static function
float WsAutoNStepBase::convertDelay(StartDelayT delay)
{
  float delaySec = 0;
  switch(delay)
  {
    case DELAY_NONE:
      delaySec = 0;
      break;
    case DELAY_1:
      delaySec = 2;
      break;
    case DELAY_2:
      delaySec = 4;
      break;
    default:
      delaySec = 0;
      break;
  }
  return delaySec;
}

/**
* Constructs a WsAutoNStepBase.  Initializes the programe state.
*/
WsAutoNStepBase::WsAutoNStepBase()
{
    a_progState = AUTO_STATE_INIT;
    a_shortCircuitTime = 0;
    ap_shortCircuitTimer = new Timer();
    if(ap_shortCircuitTimer != NULL)
    {
        ap_shortCircuitTimer->Stop();
        ap_shortCircuitTimer->Reset();
    }
    ap_dashboard = WsDashboard::getInstance();
}

/**
* Destructs a WsAccumulator
*/
WsAutoNStepBase::~WsAutoNStepBase()
{
    if(ap_shortCircuitTimer != NULL)
    {
        delete ap_shortCircuitTimer;
    }
    ap_shortCircuitTimer = NULL;
}

/**
* Initializes program parameters.  This includes initializing attributes for the init and done state as well ans
* initializing the command list to neutral values
*/
void WsAutoNStepBase::initParams(void)
{
    int i;

    // Attributes for init delay
    a_initDelay = convertDelay(a_startDelay);

    // Initialize all steps
    for(i = 0; i < MAX_STEPS; i++)
    {
        a_cmdList[i].driveType = AUTO_DRIVE_TIME;
        a_cmdList[i].throttle = 0.0;
        a_cmdList[i].wheel = 0.0;
        a_cmdList[i].shifter = WsDriveBase6WD::DEFAULT_SHIFTER_STATE;
        a_cmdList[i].driveTimeout = 0;
        a_cmdList[i].driveEncoderDist = 0;
        a_cmdList[i].driveEncoderLoc = WsDriveBase6WD::ENC_LOC_L;
        a_cmdList[i].drivePid = NULL;
        a_cmdList[i].rotateAngle = 0;
        a_cmdList[i].larmPosition = WsLarm::POSITION_NONE;
        a_cmdList[i].waitForLarm = true;
        a_cmdList[i].rollerClawSpeed = WsRollerClaw::ROLLER_OFF;
        a_cmdList[i].rollerClawRelease = WsRollerClaw::CLAW_HOLD;
    }

    a_overallEncTimeout = 0;
    a_overallEncLoc = WsDriveBase6WD::ENC_LOC_R;

    a_currentCmdIdx = 0;
    a_cmdIdx = 0;

}

/**
* Adds the command passed in to the command list if there is room.
* Note that the command is stored in the next available slot, so when calling multiple times, be careful with the order the calls.
* If there is no room left in the command list (determined by MAX_STEPS), then the command is discarded
* @param step The WsAutoNStepCmdT to add to the command list
*/
void WsAutoNStepBase::addStep(const WsAutoNStepCmdT& step)
{
    if(a_cmdIdx < MAX_STEPS)
    {
        a_cmdList[a_cmdIdx].driveType = step.driveType;
        a_cmdList[a_cmdIdx].throttle = step.throttle,
        a_cmdList[a_cmdIdx].wheel = step.wheel,
        a_cmdList[a_cmdIdx].shifter = step.shifter;
        a_cmdList[a_cmdIdx].driveTimeout = step.driveTimeout;
        a_cmdList[a_cmdIdx].driveEncoderDist = step.driveEncoderDist;
        a_cmdList[a_cmdIdx].driveEncoderLoc = step.driveEncoderLoc;
        a_cmdList[a_cmdIdx].drivePid = step.drivePid;
        a_cmdList[a_cmdIdx].rotateAngle = step.rotateAngle;
        a_cmdList[a_cmdIdx].larmPosition = step.larmPosition;
        a_cmdList[a_cmdIdx].waitForLarm = step.waitForLarm;
        a_cmdList[a_cmdIdx].rollerClawSpeed = step.rollerClawSpeed;
        a_cmdList[a_cmdIdx].rollerClawRelease = step.rollerClawRelease;

        a_cmdIdx++;
    }
}

void WsAutoNStepBase::setShortCircuit(double shortCircuitTime, const WsAutoNStepCmdT& shortCircuitCmd)
{
    a_shortCircuitTime = shortCircuitTime;

    a_shortCircuitCmd.driveType = shortCircuitCmd.driveType;
    a_shortCircuitCmd.throttle = shortCircuitCmd.throttle,
    a_shortCircuitCmd.wheel = shortCircuitCmd.wheel,
    a_shortCircuitCmd.shifter = shortCircuitCmd.shifter;
    a_shortCircuitCmd.driveTimeout = shortCircuitCmd.driveTimeout;
    a_shortCircuitCmd.driveEncoderDist = shortCircuitCmd.driveEncoderDist;
    a_shortCircuitCmd.driveEncoderLoc = shortCircuitCmd.driveEncoderLoc;
    a_shortCircuitCmd.drivePid = shortCircuitCmd.drivePid;
    a_shortCircuitCmd.rotateAngle = shortCircuitCmd.rotateAngle;
    a_shortCircuitCmd.larmPosition = shortCircuitCmd.larmPosition;
    a_shortCircuitCmd.waitForLarm = shortCircuitCmd.waitForLarm;
    a_shortCircuitCmd.rollerClawSpeed = shortCircuitCmd.rollerClawSpeed;
    a_shortCircuitCmd.rollerClawRelease = shortCircuitCmd.rollerClawRelease;
}

/**
* The main entry point for the autonomous program.  It is implemented as a state machine that does the following
* - AUTO_STATE_INIT
*   - Set all robot outputs to a neutral value
*   - Set the next state to AUTO_STATE_INIT_DELAY
* - AUTO_STATE_INIT_DELAY
*   - Set all robot outputs to a neutral value
*   - If the time specified by a_initDelay has passed since entering the state, move to AUTO_STATE_RUN_CMD
* - AUTO_STATE_RUN_CMD
*   - If there are more commands to be run
*      - Run the current command until it returns that it is done.  When that happens, the next command is chosen
*   - If there are no more commands to be run
*      - Set the program state to AUTO_STATE_DONE
* - AUTO_STATE_DONE
*   - Set all robot outputs to a neutral value
*   - Return that the program is done
*
* @returns A boolean value representing whether or not the program is done
*/
bool WsAutoNStepBase::run(void )
{
    bool done = false;
    double time = 0;
    static bool retDrive = false;
    static bool firstTime = true;
    static WsEncoder* absEnc = NULL;
    WsDriveBase6WD::ShifterStateT stayPutShifter = WsDriveBase6WD::SHIFT_STATE_HIGH;

    WsAutoNStepCmdT* currentCmd = NULL;

    
    static bool encoderTimeout = false;

    double shortCircuitTime = ap_shortCircuitTimer->Get();

    if(a_shortCircuitTime != 0 && shortCircuitTime >= a_shortCircuitTime)
    {
        currentCmd = &a_shortCircuitCmd;
    }

    if(currentCmd == NULL)
    {
        if(a_currentCmdIdx < MAX_STEPS)
        {
            currentCmd = &(a_cmdList[a_currentCmdIdx]);
        }
        else
        {
            currentCmd = NULL;
        }
    }

    switch(a_progState)
    {
        case AUTO_STATE_INIT:

            printf("N-INIT ");
            turnOffDriveBase();
            turnOffAppendages();

            a_progState = AUTO_STATE_INIT_DELAY;
            retDrive = false;
            firstTime = true;
            encoderTimeout = false;

            if(a_overallEncTimeout != 0)
            {
                //absEnc = ap_driveBase->getEncoder(a_overallEncLoc);
                //absEnc->Reset();
                //absEnc->Start();
            }
            else
            {
                absEnc = NULL;
            }

            if(ap_shortCircuitTimer != NULL)
            {
                ap_shortCircuitTimer->Reset();
                ap_shortCircuitTimer->Start();
            }


            break;
        case AUTO_STATE_INIT_DELAY:
            printf("N-INITD ");
            turnOffDriveBase();
            turnOffAppendages();

            if (delay(a_initDelay, &time) == true)
            {
                a_progState = AUTO_STATE_RUN_CMD;
                a_currentCmdIdx = 0;
            }
            //printf("DELAY %3.3f (%3.3f)\n", time, a_initDelay);
            break;
        case AUTO_STATE_RUN_CMD:
            printf("N-RUN(%d) ", a_currentCmdIdx);
            if(currentCmd != NULL)
            {
                if(encoderTimeout == false)
                {
                    printf("RUN STATE %d ", a_currentCmdIdx);

                    if(retDrive == false)
                    {
                        switch(currentCmd->driveType)
                        {
                            case AUTO_DRIVE_TIME:
                                printf("DBT ");
                                retDrive = driveByTime(currentCmd->throttle,
                                        currentCmd->wheel,
                                        currentCmd->shifter,
                                        currentCmd->larmPosition,
                                        currentCmd->waitForLarm,
                                        currentCmd->rollerClawSpeed,
                                        currentCmd->rollerClawRelease,
                                        currentCmd->driveTimeout,
                                        &time);
                                break;
                            case AUTO_DRIVE_ENCODER:
                                printf("DBE ");
                                retDrive = driveByEncoder(currentCmd->throttle,
                                        currentCmd->wheel,
                                        currentCmd->shifter,
                                        currentCmd->larmPosition,
                                        currentCmd->waitForLarm,
                                        currentCmd->rollerClawSpeed,
                                        currentCmd->rollerClawRelease,
                                        currentCmd->driveEncoderLoc,
                                        currentCmd->driveEncoderDist,
                                        true,
                                        currentCmd->driveTimeout,
                                        &time,
                                        firstTime);
                                break;
                            case AUTO_DRIVE_DIST_PID:
                                printf("DPID ");
                                retDrive = driveByDistancePid(currentCmd->throttle,
                                        currentCmd->wheel,
                                        currentCmd->shifter,
                                        currentCmd->larmPosition,
                                        currentCmd->waitForLarm,
                                        currentCmd->rollerClawSpeed,
                                        currentCmd->rollerClawRelease,
                                        currentCmd->driveEncoderLoc,
                                        currentCmd->driveEncoderDist,
                                        currentCmd->drivePid,
                                        false,
                                        currentCmd->driveTimeout,
                                        &time,
                                        firstTime);
                                break;
                            case AUTO_DRIVE_DIST_PID_SHORT_CIRCUIT:
                                printf("DPID2 ");
                                retDrive = driveByDistancePid(currentCmd->throttle,
                                        currentCmd->wheel,
                                        currentCmd->shifter,
                                        currentCmd->larmPosition,
                                        currentCmd->waitForLarm,
                                        currentCmd->rollerClawSpeed,
                                        currentCmd->rollerClawRelease,
                                        currentCmd->driveEncoderLoc,
                                        currentCmd->driveEncoderDist,
                                        currentCmd->drivePid,
                                        true,
                                        currentCmd->driveTimeout,
                                        &time,
                                        firstTime);
                                break;
                            case AUTO_DRIVE_ENCODER_DISABLE_STRAIGHT:
                                printf("DBEDS ");
                                retDrive = driveByEncoder(currentCmd->throttle,
                                        currentCmd->wheel,
                                        currentCmd->shifter,
                                        currentCmd->larmPosition,
                                        currentCmd->waitForLarm,
                                        currentCmd->rollerClawSpeed,
                                        currentCmd->rollerClawRelease,
                                        currentCmd->driveEncoderLoc,
                                        currentCmd->driveEncoderDist,
                                        false,
                                        currentCmd->driveTimeout,
                                        &time,
                                        firstTime);
                                break;
                            case AUTO_DRIVE_ROTATE:
                                printf("ROT ");
                                retDrive = rotateToAngle(currentCmd->throttle,
                                        currentCmd->wheel,
                                        currentCmd->shifter,
                                        currentCmd->larmPosition,
                                        currentCmd->waitForLarm,
                                        currentCmd->rollerClawSpeed,
                                        currentCmd->rollerClawRelease,
                                        currentCmd->rotateAngle,
                                        currentCmd->drivePid,
                                        currentCmd->driveTimeout,
                                        &time,
                                        firstTime);
                                break;
                            default:
                                printf("NONE<%d> ", currentCmd->driveType);
                                retDrive = false;
                                break;
                        }
                    }
                    else
                    {
                        printf("HOLD ");
                        setDrive(0.0, 0.0, stayPutShifter, true);
                    }

                    firstTime = false;

                    if(retDrive == true)
                    {
                        if(currentCmd == &a_shortCircuitCmd)
                        {
                            a_progState = AUTO_STATE_DONE;
                            retDrive = false;
                            firstTime = true;
                        }
                        else
                        {
                            a_currentCmdIdx++;
                            retDrive = false;
                            firstTime = true;
                        }
                    }
                }
                else
                {
                    printf("ENC TO %d ", a_currentCmdIdx);
                    a_progState = AUTO_STATE_HANDLE_ENC_TO;
                    retDrive = false;
                    firstTime = true;
                }
            }
            else
            {
                printf("NULL! ");
                a_progState = AUTO_STATE_DONE;
            }
            break;
        case AUTO_STATE_HANDLE_ENC_TO:
            printf("ENC-TO ");

            printf(" HOLD ");
            setDrive(0.0, 0.0, stayPutShifter, true);

            firstTime = false;

            break;
        case AUTO_STATE_DONE:
            printf("N-DONE ");
            setDrive(0.0, 0.0, stayPutShifter, true);
            turnOffAppendages();

            done = true;
            break;
        default:
            a_progState = AUTO_STATE_DONE;
            break;
    }

    /*
    ap_dashboard->setValue(IDX_AUTO_PROGSTATE, (UINT32)a_progState);
    ap_dashboard->setValue(IDX_AUTO_DATA1, (float)time);
    ap_dashboard->setValue(IDX_AUTO_DATA2, (float)a_currentCmdIdx);
    */
    printf("\n");

    return done;
}

