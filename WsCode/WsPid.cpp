//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang 2010
//  @ File Name : WsPid.cpp
//  @ Date : 1/14/2009
//  @ Author :
//
//


#include "WsPid.h"
#include <math.h>



/**
 * Initializes the WsPid object. All parameters default to 0.
 */
WsPid::WsPid(float p, float i, float d, int epsilon, int staticEpsilon)
{
    a_debug = false;

    a_p = p;
    a_i = i;
    a_d = d;

    a_allowStaticEpsilon = false;
    a_errorEpsilon = epsilon;

    if(staticEpsilon != 0)
    {
        a_staticEpsilon = staticEpsilon;
    }
    else
    {
        a_staticEpsilon = epsilon;
    }

    a_desiredValue = 0; // Default to 0, set later by the user
    a_firstCycle = true;
    a_maxOutput = 1.0; // Default to full range
    a_errorIncrement = 1;
    a_maxIntegral = 1.0;
    a_integralErrorThresh = -1;

    a_cycleCount = 0;
    a_minCycleCount = 10; // Default
}

WsPid::~WsPid()
{
}

float WsPid::getP(void)
{
    return a_p;
}

float WsPid::getI(void)
{
    return a_i;
}

float WsPid::getD(void)
{
    return a_d;
}

int WsPid::getEpsilon(void)
{
    return a_errorEpsilon;
}

int WsPid::getStaticEpsilon(void)
{
    return a_staticEpsilon;
}


/**
 * Sets the Pid constants to new values.
 */
void WsPid::setConstants(float p, float i, float d)
{
    a_p = p;
    a_i = i;
    a_d = d;

}

/**
 * Sets the allowable error range away from the desired value.
 */
void WsPid::setErrorEpsilon(int epsilon)
{
    a_errorEpsilon = epsilon;
}


/**
 * TODO -- WRITE A COMMENT HERE
 */
void WsPid::setStaticEpsilon(int epsilon)
{
    a_staticEpsilon = epsilon;
}

/**
 * Sets the maximum increment to the error sum used in the I component
 * calculation.
 * This defaults to 1 in the constructor, which has worked well for 1114 the
 * past few years.
 */
void WsPid::setErrorIncrement(int inc)
{
    a_errorIncrement = inc;
}

/**
 * Sets the desired value.
 */
void WsPid::setDesiredValue(int val)
{
    a_desiredValue = val;
}

/**
 * Gets the desired value.
 */
int WsPid::getDesiredValue(void)
{
    return a_desiredValue;
}

/**
 * Sets the ceiling for the output of the calculation.
 * This defaults to 1.0 (full output). Values should be between 0.0 and 1.0.
 */
void WsPid::setMaxOutput(float max)
{
    if(max >= 0.0 && max <= 1.0)
    {
        a_maxOutput = max;
    }
    else
    {
        printf("COULDN'T SET MAX OUTPUT <%f>", max);
    }
}

void WsPid::setMaxIntegral(float max)
{
    a_maxIntegral = fabs(max);
}

void WsPid::setIntegralErrorThresh(int thresh)
{
    a_integralErrorThresh = (int)fabs(thresh);
}

/**
 * Resets the error sum back to zero.
 */
void WsPid::resetErrorSum(void)
{
    a_errorSum = 0;
}

/**
 * Calculates the Pid output based on the current value.
 * The desired value will be set prior to the PID being
 * calculated. Pid constants should be set before calling
 * this function.
 */
float WsPid::calcPid(int currentValue, int desiredValue)
{
    setDesiredValue(desiredValue);
    return calcPid(currentValue);
}

/**
 * Calculates the Pid output based on the current value.
 * Pid constants and desired value should be set before calling this
 * function.
 */
float WsPid::calcPid(int currentValue)
{
    // Initialize all components to 0.0 to start.
    float pVal = 0.0;
    float iVal = 0.0;
    float dVal = 0.0;

    // Don't apply D the first time through.
    if(a_firstCycle)
    {
        a_previousValue = currentValue;  // Effective velocity of 0
        a_firstCycle = false;
    }

    // Calculate P Component.
    int error = a_desiredValue - currentValue;
    if(a_debug)
    {
        printf("Er: (%d) (%d) %d (%f)", a_desiredValue, currentValue, error, a_p);
    }
    pVal = a_p * (float)error;

    // Calculate I Component.
    // Error is positive and outside the epsilon band.
    if(error >= a_errorEpsilon)
    {
        // Check if epsilon was pushing in the wrong direction.
        if(a_errorSum < 0)
        {
            // If we are fighting away from the point, reset the error.
            a_errorSum = 0;
        }
        if(error < a_errorIncrement)
        {
            // If the error is smaller than the max increment amount, add it.
            a_errorSum += error;
        }
        else
        {
            // Otherwise, add the maximum increment per cycle.
            a_errorSum += a_errorIncrement;
        }

        if(error >= a_staticEpsilon)
        {
            a_allowStaticEpsilon = false;
        }
    }
    // Error is negative and outside the epsilon band.
    else if(error <= -a_errorEpsilon)
    {
        if(a_errorSum > 0)
        {
            // If we are fighting away from the point, reset the error.
            a_errorSum = 0;
        }
        // error is small than max contribution -> just subtract error amount
        if(error > -a_errorIncrement)
        {
            // If the error is smaller than the max increment amount, add it.
            a_errorSum += error; // Error is negative
        }
        else
        {
            // Otherwise, subtract the maximum increment per cycle.
            a_errorSum -= a_errorIncrement;
        }
        if(error <= a_staticEpsilon)
        {
            a_allowStaticEpsilon = false;
        }
    }
    // Error is inside the epsilon band.
    else
    {
        a_errorSum = 0;
        a_allowStaticEpsilon = true;
    }

    if(a_integralErrorThresh != -1)
    {
        if(error > a_integralErrorThresh ||
           error < -a_integralErrorThresh)
        {
            a_errorSum = 0;
        }
        else
        {
            //printf(" -I1- ");
        }
    }
    else
    {
        //printf(" -I2- ");
    }


    iVal = a_i * (float)a_errorSum;
    if(iVal > a_maxIntegral)
    {
        iVal = a_maxIntegral;
    }
    else if(iVal < -a_maxIntegral)
    {
        iVal = -a_maxIntegral;
    }

    // Calculate D Component.
    int velocity = currentValue - a_previousValue;
    dVal = a_d * (float)velocity;

    if(a_debug)
    {
        printf("P: %.3f I: %.3f  D: %.3f ", pVal, iVal, dVal);
    }

    // Calculate and limit the ouput: Output = P + I - D
    float output = pVal + iVal - dVal;

    //printf("SE %d ", a_allowStaticEpsilon);
    if((a_allowStaticEpsilon == true) &&
       fabs(error) < a_staticEpsilon)
    {
        output = 0;
        a_errorSum = 0;
    }

    if(output > a_maxOutput)
    {
        //printf("limit hi ");
        output = a_maxOutput;
    }
    else if(output < -a_maxOutput)
    {
        //printf("limit lo ");
        output = -a_maxOutput;
    }
    else
    {
        //printf("limit no ");
    }

    // Save the current value for next cycle's D calculation.
    a_previousValue = currentValue;

    return output;
}

/**
 * Sets the minimum number of cycles the value must be in the epsilon range
 * before the system is considered stable.
 */
void WsPid::setMinDoneCycles(int n)
{
    a_minCycleCount = n;
}

/**
 * Returns true if the last input was within the epsilon range of the
 * destination value, and the system is stable.
 */
bool WsPid::isDone(void)
{
    if (a_previousValue <= a_desiredValue + a_errorEpsilon &&
        a_previousValue >= a_desiredValue - a_errorEpsilon &&
        !a_firstCycle)
    {
        if(a_cycleCount >= a_minCycleCount)
        {
            return true;
        }
        else
        {
            a_cycleCount++;
            return false;
        }
    }
    a_cycleCount = 0;
    return false;
}

void WsPid::setDebug(bool debug)
{
    a_debug = debug;
}
