//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : WsDriveBase6WD.cpp
//  @ Date : 1/24/2011
//  @ Author : 
//
//


#include "WsDriveBase6WD.h"
#include "WsDriveVector.h"
#include "WsEncoder.h"
#include "Jaguar.h"
#include "WsTrig.h"
#include "WsCalibration.h"
#include "WsDashboard.h"
#include "WsPid.h"
#include "WsUtils.h"
#include "WsGyro.h"

#define USE_SCALE_DRIVE 0
#define USE_DRIVE_STRAIGHT 1
#define USE_GYRO 1
#define IFI_GYRO 0

WsDriveBase6WD::WsDriveBase6WD(UINT32 driveL1_sc, UINT32 driveL2_sc, 
                   UINT32 driveR1_sc, UINT32 driveR2_sc, 
                   UINT32 encoder_lA, UINT32 encoder_lB,
                   UINT32 encoder_rA, UINT32 encoder_rB,
                   UINT32 gyroChannel,
                   UINT32 shift_sol)
{
    ap_calib = WsCalibration::getInstance();

    if(ap_calib->isCompetitionRobot() == true)
    {
        // LOW GEAR w/ Cheesy
        //ap_driveStraightLowPid = new WsPid(.08, 0, .025, 0, 0);
        //ap_driveStraightHighPid = new WsPid(.08, 0, .025, 0, 0);
        ap_driveStraightLowPid = new WsPid(.00025, 0, 0, 0, 0);
        //ap_driveStraightHighPid = new WsPid(.00035, 0, 0, 0, 0);
        ap_driveStraightHighPid = new WsPid(.0003, 0, 0, 0, 0);
        a_driveStraightLowLeftScale = 1;
        a_driveStraightLowRightScale = 1;
        a_driveStraightHighLeftScale = 1;
        //a_driveStraightHighRightScale = .81;
        a_driveStraightHighRightScale = 1;
    }
    else
    {
        /* ENCODER BASED

        ap_driveStraightLowPid = new WsPid(.05, 0, 0, 0, 0);
        ap_driveStraightHighPid = new WsPid(.08, 0, .025, 0, 0);
        */

        /** GYRO BASED **/
        ap_driveStraightLowPid = new WsPid(.00025, 0, 0, 0, 0);
        ap_driveStraightHighPid = new WsPid(.00025, 0, 0, 0, 0);

#if 0
        a_driveStraightLowLeftScale = .95;
        a_driveStraightLowRightScale = 1;
        a_driveStraightHighLeftScale = .97;
        a_driveStraightHighRightScale = 1;
#else
        a_driveStraightLowLeftScale = 1;
        a_driveStraightLowRightScale = 1;
        a_driveStraightHighLeftScale = 1;
        a_driveStraightHighRightScale = 1;
#endif
    }
    //ap_driveStraightPid = new WsPid(.075, 0, .0, 0, 0);
    //ap_driveStraightPid = new WsPid(.05, .001, 0, 0, 0);

    /*
    if(ap_calib->isOldRobot())
    {
        ap_scLeft1 = new Jaguar(driveL1_sc);
        ap_scLeft2 = new Jaguar(driveL2_sc);
        ap_scRight1 = new Jaguar(driveR1_sc);
        ap_scRight2 = new Jaguar(driveR2_sc);
    }
    else
    */
    {
        ap_scLeft1 = new Victor(driveL1_sc);
        ap_scLeft2 = new Victor(driveL2_sc);
        ap_scRight1 = new Victor(driveR1_sc);
        ap_scRight2 = new Victor(driveR2_sc);
    }
    ap_encL = new WsEncoder(encoder_lA, encoder_lB);
    ap_encR = new WsEncoder(encoder_rA, encoder_rB, true);
    
    ap_encL->Reset();
    ap_encL->Start();
    ap_encR->Reset();
    ap_encR->Start();
    
#if USE_GYRO
    ap_gyro = new WsGyro(gyroChannel);
#if IFI_GYRO
    ap_gyro->SetSensitivity(0.0033);
#endif
    ap_gyro->Reset();
#endif

    ap_shifter = new Solenoid(shift_sol);
    a_shifterState = SHIFT_STATE_LOW;
    
    a_prevLSpeed = 0;
    a_prevRSpeed = 0;
    a_curEncLeft = 0;
    a_curEncRight = 0;
    a_currEncDiff = 0;
    a_cmdSpeedLeft = 0;
    a_cmdSpeedRight = 0;
    a_adjSpeedLeft = 0;
    a_adjSpeedRight = 0;

    a_accelerationFactor = 0.1;
    
    a_driveStraightScaleFactor = .0001;
    a_prevDriveVector = new WsDriveVector();
    a_prevDriveVector->a_direction = 90;
    a_driveStraightSnapFlag = true;
    a_cachedGyroAngle = 0;
}

WsDriveBase6WD::~WsDriveBase6WD(void )
{
    delete ap_scLeft1;
    ap_scLeft1 = NULL;

    delete ap_scLeft2;
    ap_scLeft2 = NULL;

    delete ap_scRight1;
    ap_scRight1 = NULL;

    delete ap_scRight2;
    ap_scRight2 = NULL;

    delete ap_encL;
    ap_encL = NULL;

    delete ap_encR;
    ap_encR = NULL;

#if USE_GYRO
    delete ap_gyro;
    ap_gyro = NULL;
#endif
    delete ap_shifter;
    ap_shifter = NULL;

    delete ap_driveStraightLowPid;
    ap_driveStraightLowPid = NULL;

    delete ap_driveStraightHighPid;
    ap_driveStraightHighPid = NULL;
}

void WsDriveBase6WD::setVector(float speed, float turnRate, bool useDriveStraight, bool useCheesy)
{
    float angular_power = 0.0;
    float wheel = -turnRate;
    float throttle = -speed;
    float OverPower = 0.0;

    float sensitivity = 1.7;
    float right_power = 0.0;
    float left_power = 0.0;

    bool quickturn = false;

    if(fabs(throttle) < .1 &&
       fabs(turnRate) > .1)
            //(throttle < .1 && throttle > -.1)
    {
        throttle = 0;
        quickturn = true;
    }

    if(quickturn) {
        OverPower = 1.0;
        sensitivity = 1.0;
        angular_power = wheel;
    } else {
        OverPower = 0.0;
        angular_power = fabs(throttle) * wheel * sensitivity;
    }

    right_power = left_power = throttle;
    left_power += angular_power;
    right_power -= angular_power;

    if (left_power > 1.0) {
        right_power -= OverPower*(left_power - 1.0);
        left_power = 1.0;
    } else if (right_power > 1.0) {
        left_power -= OverPower*(right_power - 1.0);
        right_power = 1.0;
    } else if (left_power < -1.0) {
        right_power += OverPower*(-1.0 - left_power);
        left_power = -1.0;
    } else if (right_power < -1.0) {
        left_power += OverPower*(-1.0 - right_power);
        right_power = -1.0;
    }
    
    if(useDriveStraight == true)
    {

        if(a_shifterState == SHIFT_STATE_LOW)
        {
            ap_driveStraightPid = ap_driveStraightLowPid;
            ap_driveStraightHighPid->resetErrorSum();
        }
        else
        {
            ap_driveStraightPid = ap_driveStraightHighPid;
            ap_driveStraightLowPid->resetErrorSum();
        }
        
        
#if USE_SCALE_DRIVE
        if((throttle > 0.1) || (throttle < -0.1))
        {
            if(a_shifterState == SHIFT_STATE_LOW)
            {
                left_power *= a_driveStraightLowLeftScale;
                right_power *= a_driveStraightLowRightScale;
            }
            else
            {
                left_power *= a_driveStraightHighLeftScale;
                right_power *= a_driveStraightHighRightScale;
            }
        }
#endif
        
        

#if USE_DRIVE_STRAIGHT
        if((throttle > 0.1) || (throttle < -0.1))
        {
            if(fabs(wheel) < .1)
            {
                // DO THIS CORRECTLY ON THE INPUT SIDE
                left_power = right_power;

                if(a_driveStraightSnapFlag == true)
                {
                    ap_driveStraightHighPid->resetErrorSum();
                    ap_driveStraightLowPid->resetErrorSum();
                    //resetEncoder(ENC_LOC_L);
                    //resetEncoder(ENC_LOC_R);
                    //readEncoders();
                    readGyro();
                    a_snappedGyro = a_cachedGyroAngle;

                    //a_curEncLeft = getEncoderValue(ENC_LOC_L);
                    //a_curEncRight = getEncoderValue(ENC_LOC_R);

                    a_driveStraightSnapFlag = false;
                }    
                //printf("l: %.3f  r: %.3f  ", leftSpeed, rightSpeed);
                if(a_shifterState == SHIFT_STATE_LOW)
                {
                    left_power *= a_driveStraightLowLeftScale;
                    right_power *= a_driveStraightLowRightScale;
                }
                else
                {
                    left_power *= a_driveStraightHighLeftScale;
                    right_power *= a_driveStraightHighRightScale;
                }
                driveStraight(&left_power, &right_power);
                //printf("--> l: %.3f  r: %.3f\n", leftSpeed, rightSpeed);
            }
            else
            {
                a_driveStraightSnapFlag = true;
            }
        }
        else
        {
            a_driveStraightSnapFlag = true;
        }


        printf("OUT: %.3f %.3f\n", left_power, right_power);


#endif

    }
    a_adjSpeedLeft = left_power;
    a_adjSpeedRight = right_power;


    float right_power_real = right_power;
    float left_power_real = left_power;

    if(useCheesy)
    {
        right_power_real = WsUtils::LinearizeVictor(right_power);
        left_power_real = WsUtils::LinearizeVictor(left_power);
    }

    if(left_power_real > 1)
    {
        left_power_real = 1;
    }
    else if(left_power_real < -1)
    {
        left_power_real = -1;
    }

    if(right_power_real > 1)
    {
        right_power_real = 1;
    }
    else if(right_power_real < -1)
    {
        right_power_real = -1;
    }

    ap_scLeft1->Set(left_power_real);
    ap_scLeft2->Set(left_power_real);
    ap_scRight1->Set(right_power_real);
    ap_scRight2->Set(right_power_real);
}



//void WsDriveBase6WD::setVector(WsDriveVector *p_driveVector, bool useDriveStraight)
#if 0
void WsDriveBase6WD::setVectorNonCheesy(float speed, float turnRate, bool useDriveStraight)
{
    float angle = 0;
    float radius = 0;

    float leftSpeed = 0;
    float rightSpeed = 0;

    //a_curEncLeft = getEncoderValue(ENC_LOC_L);
    //a_curEncRight = getEncoderValue(ENC_LOC_R);

    if( p_driveVector != NULL )
    {
        angle = p_driveVector->a_direction;
        radius = p_driveVector->a_speed;
    }

    leftSpeed = radius * ( COSDEG( angle ) + SINDEG( angle ) );
    rightSpeed = radius * ( COSDEG( angle ) - SINDEG( angle ) );

    //printf("pR: %1.4f pL: %1.4f sR: %1.4f sL: %1.4f ", a_prevRSpeed, a_prevLSpeed, rightSpeed, leftSpeed);
    
    //printf(" %1.3f  %1.3f -> ", leftSpeed, rightSpeed);
    rightSpeed = applyAcceleration(rightSpeed, a_prevRSpeed);
    leftSpeed = applyAcceleration(leftSpeed, a_prevLSpeed);
    a_prevLSpeed = leftSpeed;
    a_prevRSpeed = rightSpeed;
    
    a_cmdSpeedLeft = leftSpeed;
    a_cmdSpeedRight = rightSpeed;

    if(useDriveStraight)
    {
#if USE_DRIVE_STRAIGHT
        if((radius > 0.1) || (radius < -0.1))
        {

            if((fabs(angle) < 2) || (fabs(angle - 180.0) < 2))
            {
                // DO THIS CORRECTLY ON THE INPUT SIDE
                leftSpeed = rightSpeed;

                if(a_driveStraightSnapFlag == true)
                {
                    //a_snappedGyro = a_cachedGyroAngle;
                    resetEncoder(ENC_LOC_L);
                    resetEncoder(ENC_LOC_R);

                    //readEncoders();
                    //a_curEncLeft = getEncoderValue(ENC_LOC_L);
                    //a_curEncRight = getEncoderValue(ENC_LOC_R);

                    a_driveStraightSnapFlag = false;
                }    
                //printf("l: %.3f  r: %.3f  ", leftSpeed, rightSpeed);
                driveStraight(&leftSpeed, &rightSpeed);
                //printf("--> l: %.3f  r: %.3f\n", leftSpeed, rightSpeed);
            }
            else
            {
                a_driveStraightSnapFlag = true;
            }
        }
        else
        {
            a_driveStraightSnapFlag = true;
        }
#endif
    }
    a_adjSpeedLeft = leftSpeed;
    a_adjSpeedRight = rightSpeed;
    //printf("tR: %1.4f tL: %1.4f\n", rightSpeed, leftSpeed);
 
    //printf( " L:%0.5f, R:%0.5f\n", leftSpeed, rightSpeed );

    //printf(" %1.3f  %1.3f\n", leftSpeed, rightSpeed);


    printf("(%.3f, %.3f) -> ", leftSpeed, rightSpeed);
    leftSpeed = WsUtils::LinearizeVictor((double)leftSpeed);
    rightSpeed = WsUtils::LinearizeVictor((double)rightSpeed);
    printf("(%.3f, %.3f)\n", leftSpeed, rightSpeed);

    ap_scLeft1->Set(leftSpeed);
    ap_scLeft2->Set(leftSpeed);
    ap_scRight1->Set(rightSpeed);
    ap_scRight2->Set(rightSpeed);
    
    a_prevDriveVector->a_speed = p_driveVector->a_speed;
    a_prevDriveVector->a_direction = p_driveVector->a_direction;
    a_prevDriveVector->a_x = p_driveVector->a_x;
    a_prevDriveVector->a_y = p_driveVector->a_y;
}
#endif


float WsDriveBase6WD::applyAcceleration(float speed, float prevSpeed)
{
    float outSpeed = 0;
    float speedDiff = speed - prevSpeed;
    
   // printf("speeddiff: %1.6f ", speedDiff);
    
    if(speedDiff >= a_accelerationFactor)
    {
        outSpeed = prevSpeed + a_accelerationFactor;
    }
    else if(speedDiff <= (-1 * a_accelerationFactor))
    {
        outSpeed = prevSpeed - a_accelerationFactor;
    }
    else
    {
        outSpeed = speed;
    }

    if(outSpeed > 1.0)
    {
        outSpeed = 1.0;
    }
    else if(outSpeed < -1.0)
    {
        outSpeed = -1.0;
    }

    return outSpeed;
}


//note that if offset is > 0, a_encR is larger, and if it's < 0 a_encL is larger
void WsDriveBase6WD::driveStraightOld(float* leftSpeed, float* rightSpeed)
{
    // Positive offset means drifting left
    INT32 curOffset = a_curEncRight - a_curEncLeft;
    float speedCorrection = a_driveStraightScaleFactor * curOffset;

    float currentLeftSpeed = *leftSpeed;
    float currentRightSpeed = *rightSpeed;


    if(curOffset >= 0)
    {
        /*

                IF SPEED IS POSITIVE
                    CASE 1
                    SLOW DOWN RIGHT SIDE
                ELSE
                    CASE 2
                    SLOW DOWN LEFT SIDE

        */

        if(currentLeftSpeed >= 0)
        {
            if(currentRightSpeed - speedCorrection >= 0)
            {
                *rightSpeed -= speedCorrection;
            }
            else
            {
                *rightSpeed = 0;
            }

        }
        else
        {

            // speed = -.5
            // offset = 1 --> correction = .001

            printf("--2--");
            speedCorrection *= -1;

            // correction = -.001

            if(currentLeftSpeed - speedCorrection <= 0)
            {
                *leftSpeed -= speedCorrection;
            }
            else
            {
                *leftSpeed = 0;
            }
        }
    }
    else
    {
        /*

                IF SPEED IS POSITIVE
                    CASE 3
                    SLOW DOWN LEFT SIDE
                ELSE
                    CASE 4
                    SLOW DOWN RIGHT SIDE
                    */

        if(currentLeftSpeed >= 0)
        {
            speedCorrection *= -1;

            if(currentLeftSpeed - speedCorrection <= 0)
            {
                *leftSpeed -= speedCorrection;
            }
            else
            {
                *leftSpeed = 0;
            }
        }
        else
        {
            if(currentRightSpeed - speedCorrection >= 0)
            {
                *rightSpeed -= speedCorrection;
            }
            else
            {
                *rightSpeed = 0;
            }
        }
    }
    a_currEncDiff = curOffset;
}

void WsDriveBase6WD::driveStraight(float* leftSpeed, float* rightSpeed)
{
    int sideMultiplier = 1;
    float *sideSpeed = leftSpeed;
    float adjustmentSpeed = 0;
    float maxAdjustment = 0.0;
    float currentLeftSpeed = *leftSpeed;
    float currentRightSpeed = *rightSpeed;

    float currentAngle = a_cachedGyroAngle;
    float targetAngle = a_snappedGyro;

    if(currentAngle > 180)
    {
        currentAngle -= 360;
    }

    if(targetAngle > 180)
    {
        targetAngle -= 360;
    }

    // Calculate the difference in encoders
    //INT32 offset = a_curEncRight - a_curEncLeft;
    //float offset = a_cachedGyroAngle - a_snappedGyro;
    float offset = currentAngle - targetAngle;







    printf("%f ",  offset);
    
    // store the offset for the dashboard
    //a_currEncDiff = offset;

    if(offset >= 0)
    {
        if(currentLeftSpeed < 0)
        {
            // Positive offset, positive speed
            // Driving forward drifting to the left
            // Slow down right side
            sideSpeed = rightSpeed;
            sideMultiplier = -1;
            maxAdjustment = currentRightSpeed;
            printf("REV L ");
        }
        else
        {
            // Positive offset, negative speed
            // Driving backward drifting to the right
            // Slow down left side
            sideSpeed = leftSpeed;
            //sideMultiplier = -1;
            maxAdjustment = currentLeftSpeed * -1;
            printf("FWD R ");
        }
    }
    else
    {
        if(currentLeftSpeed < 0)
        {
            // Negative offset, positive speed
            // Driving forward drifting to the right
            // Slow down left side
            sideSpeed = leftSpeed;
            maxAdjustment = currentLeftSpeed;
            printf("REV R ");
        }
        else
        {
            // Negative offset, negative speed
            // Driving backward drifting to the left
            // Slow down right side
            sideSpeed = rightSpeed;
            sideMultiplier = -1;
            maxAdjustment = currentRightSpeed * -1;
            printf("FWD L ");
        }
    }
    //printf("IN %.3f ", currentLeftSpeed);

    // The PID output is capped so that the output
    // speed never causes us to drive the opposite
    // direction
    maxAdjustment = fabs(maxAdjustment);
    ap_driveStraightPid->setMaxOutput(maxAdjustment);
    
    // Calculate the adjustment speed.  We want to drive
    // the offset to 0
    //adjustmentSpeed = ap_driveStraightPid->calcPid((int)fabs(offset), 0);


    adjustmentSpeed = ap_driveStraightPid->calcPid((int)(1000 * currentAngle), (int)(targetAngle * 1000));
    adjustmentSpeed *= -1;
    printf("OFFSET %f  ADJ %f ", offset, adjustmentSpeed);

    // Multiply by the side multiplier to account for inverted
    // values
    adjustmentSpeed *= sideMultiplier;
    // Adjust the necessary output speed
    *sideSpeed -= adjustmentSpeed;

    //*sideSpeed *= (1 - fabs(adjustmentSpeed));

    printf(" OUT %f ", *sideSpeed);
    //printf(" L: %.3f  R: %3f\n", *leftSpeed, *rightSpeed);
}

void WsDriveBase6WD::setShifter(ShifterStateT state)
{
    if(state != SHIFT_STATE_NONE)
    {
        bool solState = SHIFTER_OUTPUT_LOW;

        if(state == SHIFT_STATE_HIGH)
        {
            solState = SHIFTER_OUTPUT_HIGH;
        }

        a_shifterState = state;
        ap_shifter->Set(solState);
        //printf("STATE %d OUT %d\n", state, solState);
    }
    else
    {
        //printf("HOLD ");
    }
}

WsEncoder* WsDriveBase6WD::getEncoder(EncoderLocationT encLoc)
{
    WsEncoder* enc = NULL;
    switch( encLoc )
    {
    case ENC_LOC_L:
        enc = ap_encL;
        break;
    case ENC_LOC_R:
        enc = ap_encR;
        break;
    default:
        break;
    }
    return enc;
}

INT32 WsDriveBase6WD::getEncoderValue(EncoderLocationT encLoc)
{
    INT32 distance = 0;

    switch( encLoc )
    {
    case ENC_LOC_L:
        distance = ap_encL->Get();
        break;
    case ENC_LOC_R:
        distance = ap_encR->Get();
        break;
    default:
        break;
    }
    
    return distance;
}

void WsDriveBase6WD::readSensors(void)
{
    readGyro();
    readEncoders();
}

void WsDriveBase6WD::readGyro(void)
{
#if USE_GYRO
    a_cachedGyroAngle = ap_gyro->GetAngle();
    //printf("<%.3f>\n", a_cachedGyroAngle);
#else
    a_cachedGyroAngle = 0;
#endif
}

void WsDriveBase6WD::readEncoders(void)
{
    a_curEncLeft = ap_encL->Get();
    a_curEncRight = ap_encR->Get();
    //printf("L: %d R: %d\n", a_curEncLeft, a_curEncRight);
}

    
float WsDriveBase6WD::getGyroAngle(void)
{
    return a_cachedGyroAngle;
}

void WsDriveBase6WD::reset(void)
{
    a_driveStraightSnapFlag = true;
    a_snappedGyro = 0;
    ap_driveStraightHighPid->resetErrorSum();
    ap_driveStraightLowPid->resetErrorSum();
}

void WsDriveBase6WD::resetGyro(void)
{
#if USE_GYRO
    ap_gyro->Reset();
    readGyro();
#endif
}

void WsDriveBase6WD::resetEncoder(EncoderLocationT encLoc)
{
    switch( encLoc )
    {
    case ENC_LOC_L:
        ap_encL->Reset();
        break;
    case ENC_LOC_R:
        ap_encR->Reset();
        break;
    default:
        break;
    }
}

void WsDriveBase6WD::dashGetOutputSpeeds(float *leftSpeed, float *rightSpeed)
{
    if(leftSpeed != NULL)
    {
        *leftSpeed = a_prevLSpeed;
    }
    if(rightSpeed != NULL)
    {
        *rightSpeed = a_prevRSpeed;
    }
}

void WsDriveBase6WD::dashGetEncoderVals(INT32 *leftEnc, INT32 *rightEnc)
{
    if(leftEnc != NULL)
    {
        *leftEnc = a_curEncLeft;
    }
    if(rightEnc != NULL)
    {
        *rightEnc = a_curEncRight;
    }
}

bool WsDriveBase6WD::dashGetShifter()
{
    return ap_shifter->Get();
}

void WsDriveBase6WD::dashGetDriveStraightParams(float *cmd_left,
                                                float *cmd_right,
                                                float *adj_left,
                                                float *adj_right,
                                                INT32 *enc_snap,
                                                INT32 *enc_diff)
{
    if(cmd_left != NULL)
    {
        *cmd_left = a_cmdSpeedLeft;
    }

    if(cmd_right != NULL)
    {
        *cmd_right = a_cmdSpeedRight;
    }
    if(adj_left != NULL)
    {
        *adj_left = a_adjSpeedLeft;
    }
    if(adj_right != NULL)
    {
        *adj_right = a_adjSpeedRight;
    }
    if(enc_snap != NULL)
    {
        *enc_snap = 0;
    }
    if(enc_diff != NULL)
    {
        *enc_diff = a_currEncDiff;
    }
}

float WsDriveBase6WD::dashGetGyroAngle(void)
{
    return getGyroAngle();
}
