//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutoSixStepBase.h
//  @ Date : 3/12/2009
//  @ Author : 
//
//


#if !defined(_WSAUTONSTEPBASE_H)
#define _WSAUTONSTEPBASE_H

#include <stdio.h>
#include "WsAutoProgramBase.h"

#include "WsDriveVector.h"
#include "WsDriveBase6WD.h"
#include "WsLarm.h"

class Timer;
class Dashboard;


/**
* The base class for autonomous programs that are step based
*/

class WsAutoNStepBase : public WsAutoProgramBase
{
public:

    static const UINT8 MAX_STEPS = 20;  /*!< The maximum number of steps allowed */

    typedef enum
    {
        AUTO_STATE_INIT,           /**< Initialization state */
        AUTO_STATE_INIT_DELAY,     /**< Delay between initialization and running commands  */
        AUTO_STATE_RUN_CMD,        /**< Run commands until there are none left */
        AUTO_STATE_HANDLE_ENC_TO,  /**< Handles when the overall encoder count is reached */
        AUTO_STATE_SHORT_CIRCUIT,  /**< Handles when the overall encoder count is reached */
        AUTO_STATE_DONE            /**< Done state  */
    } WsAutoNStepStateT;

    typedef enum
    {
        AUTO_DRIVE_TIME,
        AUTO_DRIVE_ENCODER,
        AUTO_DRIVE_DIST_PID,
        AUTO_DRIVE_DIST_PID_SHORT_CIRCUIT,
        AUTO_DRIVE_ROTATE,
        AUTO_DRIVE_ENCODER_DISABLE_STRAIGHT,
    } WsAutoDriveTypeT;

    typedef struct
    {
        WsAutoDriveTypeT driveType;              /**< The command type */
        float throttle;
        float wheel;
        WsDriveBase6WD::ShifterStateT shifter;
        double driveTimeout;         /**< How long to drive.  In seconds (i.e. 1.0, 0.5) */
        INT32 driveEncoderDist;      /**< How far to drive by encoder.  If set to 0, we will drive by time */
        WsDriveBase6WD::EncoderLocationT driveEncoderLoc;      /**< Which encoder to use */
        WsPid* drivePid;      /**< The PID object to use to for drive feedback */
        INT32 rotateAngle;
        WsLarm::PositionT larmPosition;
        bool waitForLarm;
        WsRollerClaw::RollerSpeedT rollerClawSpeed;
        WsRollerClaw::ReleaseStateT rollerClawRelease;
    } WsAutoNStepCmdT;

    static float convertDelay(StartDelayT delay);

    WsAutoNStepBase();
    virtual ~WsAutoNStepBase();
    virtual bool run(void );
    virtual void addStep(const WsAutoNStepCmdT& cmd);
    virtual void initParams(void);

    void setShortCircuit(double shortCircuitTime, const WsAutoNStepCmdT& shortCircuitCmd);



protected:
    WsAutoNStepStateT a_progState;         /*!< The internal state of the program */
    double a_shortCircuitTime;
    WsAutoNStepCmdT a_shortCircuitCmd;
    Timer* ap_shortCircuitTimer;

    INT32 a_overallEncTimeout;
    WsDriveBase6WD::EncoderLocationT a_overallEncLoc;

    // Attributes for init

    // Attributes for init delay
    double a_initDelay;                     /*!< The amount of time in seconds that the program should wait in the INIT_DELAY state */

    WsAutoNStepCmdT a_cmdList[MAX_STEPS];   /*!< A list of size MAX_STEPS of WsAutoNStepCmdT commands to run */

    UINT8 a_cmdIdx;                         /*!< The command index used during setup */
    UINT8 a_currentCmdIdx;                     /*!< The current command that the program is running */
};

#endif  //_WSAUTONSTEPBASE_H
