//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutoProgramBase.h
//  @ Date : 2/8/2009
//  @ Author : 
//
//


#if !defined(_WSAUTOPROGRAMBASE_H)
#define _WSAUTOPROGRAMBASE_H

#include <stdio.h>
#include "WsDriveBase6WD.h"
#include "WsLarm.h"

class WsDriveVector;
class WsDashboard;
class WsPid;
class Timer;
class WsCalibration;

/**
* This base class is used by all autonomous programs.  It contains general common
* building blocks that inheriting classes can use.
*/

class WsAutoProgramBase
{
public:
    typedef enum
    {
        DELAY_NONE,
        DELAY_1,
        DELAY_2,
    } StartDelayT;

    typedef enum
    {
        RACK_LEFT,
        RACK_RIGHT
    } RackPositionT;

    typedef enum
    {
        COL_LEFT,
        COL_MID,
        COL_RIGHT,
    } ColPositionT;

    typedef enum
    {
        PEG_HIGH,
        PEG_MID,
        PEG_LOW,
    } PegHeightT;

    static float convertDelay(StartDelayT delay);

    WsAutoProgramBase();
    virtual ~WsAutoProgramBase();
    virtual bool run(void );
    /**
    * A purely virtual function that children will use to initialize their parameters
    */
    virtual void initParams(void) = 0;
    void assignDriveBase(WsDriveBase6WD* p_driveBase);
    void assignAppendages( WsLarm* p_larm);
    void setStartDelay(StartDelayT delay);
    void setTargetPeg(RackPositionT rackPosition, ColPositionT colPosition, PegHeightT pegHeight);
    void turnOffDriveBase(void );
    void turnOffAppendages(void );
    bool delay(double delayTime, double* p_currentTime, bool forceStop = false);
    //void setDrive(WsDriveVector* p_driveVector, WsDriveBase6WD::ShifterStateT shifterState);
    void setDrive(float throttle, float wheel, WsDriveBase6WD::ShifterStateT shifterState,bool useDriveStraight);
    void setLarm( WsLarm::PositionT larmPosition,
                  WsRollerClaw::RollerSpeedT rollerState,
                  WsRollerClaw::ReleaseStateT releaseState);
    //bool driveByTime(WsDriveVector* p_driveVector,
    bool driveByTime(float throttle,
                     float wheel,
                     WsDriveBase6WD::ShifterStateT shifterState,
                     WsLarm::PositionT larmPosition,
                     bool waitForLarm,
                     WsRollerClaw::RollerSpeedT rollerClawSpeed,
                     WsRollerClaw::ReleaseStateT rollerClawRelease,
                     double driveTime,
                     double* p_currentTime);
    bool coast(WsDriveBase6WD::ShifterStateT,
               WsLarm::PositionT larmPosition,
               bool waitForLarm,
               WsRollerClaw::RollerSpeedT rollerClawSpeed,
               WsRollerClaw::ReleaseStateT rollerClawRelease,
               double delayTime,
               double* p_currentTime);
    bool driveByEncoder(float throttle,
                        float wheel,
                        WsDriveBase6WD::ShifterStateT shifterState,
                        WsLarm::PositionT larmPosition,
                        bool waitForLarm,
                        WsRollerClaw::RollerSpeedT rollerClawSpeed,
                        WsRollerClaw::ReleaseStateT rollerClawRelease,
                        WsDriveBase6WD::EncoderLocationT encoderLoc,
                        INT32 encoderTarget,
                        bool useDriveStraight,
                        double timeout,
                        double* p_currentTime,
                        bool reinit = false);
    bool driveByDistancePid(float throttle,
                        float wheel,
                        WsDriveBase6WD::ShifterStateT shifterState,
                        WsLarm::PositionT larmPosition,
                        bool waitForLarm,
                        WsRollerClaw::RollerSpeedT rollerClawSpeed,
                        WsRollerClaw::ReleaseStateT rollerClawRelease,
                        WsDriveBase6WD::EncoderLocationT encoderLoc,
                        INT32 encoderTarget,
                        WsPid* p_pid,
                        bool shortCircuit,
                        double timeout,
                        double* p_currentTime,
                        bool reinit = false);
    bool rotateToAngle(float throttle,
                       float wheel,
                       WsDriveBase6WD::ShifterStateT shifterState,
                       WsLarm::PositionT larmPosition,
                       bool waitForLarm,
                       WsRollerClaw::RollerSpeedT rollerClawSpeed,
                       WsRollerClaw::ReleaseStateT rollerClawRelease,
                       INT32 desiredAngle,
                       WsPid* p_pid,
                       double timeout,
                       double* p_currentTime,
                       bool reinit);


protected:
    WsDriveBase6WD* ap_driveBase;  /*!< The drive base to control */
    WsLarm* ap_larm;
    WsDashboard* ap_dashboard;            /*!< The dashboard to send updates to */
    Timer* ap_timer;                      /*!< A timer to be used as needed*/
    bool a_timerStartFlag;                /*!< A flag to denote whether the timer needs to be restarted */
    StartDelayT a_startDelay;             /*!< How long to delay the start of the program */
    RackPositionT a_rackPosition;
    ColPositionT a_colPosition;
    PegHeightT a_pegHeight;
    float a_pidMaxValue;
    WsCalibration* ap_calib;
};

#endif  //_WSAUTOPROGRAMBASE_H
