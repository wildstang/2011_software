//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutonomousMgr.cpp
//  @ Date : 2/8/2009
//  @ Author : 
//
//

#include <string.h>

#include "WsAutonomousMgr.h"
#include "InputManager.h"
#include "WsAutoProgramBase.h"

#include "WsAutoSleeper.h"
#include "WsAutoProgramScoreStraight.h"
#include "WsAutoProgramScoreAngle.h"
#include "WsAutoProgramScoreDouble.h"
#include "WsDashboard.h"
#include "WsDriverStationLED.h"

//TODO MOVE THESE TO BE MEMBERS
#define MAX_NUM_PROG 11
const char progNames[][MAX_NUM_PROG][PROG_NAME_LEN] = {
  /* left */   { "Sleeper", "StraightL",  "AngleL",  "DoubleL", "StraightL2", "AngleL2", "StraightL3", "AngleL3", "Sleeper", "Sleeper", "Sleeper"},
  /* right  */ { "Sleeper", "StraightR", "AngleR", "DoubleR", "StraightR2", "AngleR2", "StraightR3", "AngleR3", "Sleeper", "Sleeper", "Sleeper"},
                                                      };

WsAutonomousMgr::WsAutonomousMgr(WsDriverStationLED* p_lockInLed)
{
    ap_inputManager = InputManager::Instance();
    ap_lockInLed = p_lockInLed;
    initializeAutonomousMgr();
}


void WsAutonomousMgr::initializeAutonomousMgr(void)
{
    ap_program = NULL;

    ap_driveBase = NULL;

    a_progNum = 1;

    a_rackPosition = WsAutoProgramBase::RACK_LEFT;
    a_colPosition = WsAutoProgramBase::COL_RIGHT;
    a_pegHeight = WsAutoProgramBase::PEG_HIGH;

    a_delay = WsAutoProgramBase::DELAY_NONE;
    a_lockedIn = false;

    a_hasRun = false;
    a_autoDone = false;

    memset(a_progName, 0, PROG_NAME_LEN);
    strncpy(a_progName, "Sleeper", PROG_NAME_LEN);

    ap_dashboard = WsDashboard::getInstance();
}

WsAutonomousMgr::~WsAutonomousMgr()
{
    if(ap_program != NULL)
    {
        delete ap_program;
    }
    ap_program = NULL;
}

void WsAutonomousMgr::assignDriveBase(WsDriveBase6WD* p_driveBase)
{
    ap_driveBase = p_driveBase;
}

void WsAutonomousMgr::assignAppendages(WsLarm* p_larm)
{
    ap_larm = p_larm;
}


UINT8 WsAutonomousMgr::getProgNum(void)
{
    if(a_lockedIn == true)
    {
        return a_progNum;
    }
    else
    {
        return a_tempProgNum;
    }

}

float WsAutonomousMgr::getStartDelay(void)
{
    if(a_lockedIn == true)
    {
        return WsAutoProgramBase::convertDelay(a_delay);
    }
    else
    {
        return WsAutoProgramBase::convertDelay(a_tempDelay);
    }
}

bool WsAutonomousMgr::getLockState(void)
{
    return a_lockedIn;
}

void WsAutonomousMgr::getProgName(char* p_name)
{
    if(p_name != NULL)
    {
        strncpy(p_name, a_progName, PROG_NAME_LEN);
    }
}

WsAutoProgramBase::RackPositionT WsAutonomousMgr::getRackPosition(void)
{
    if(a_lockedIn == true)
    {
        return a_rackPosition;
    }
    else
    {
        return a_temp_rackPosition;
    }
}

WsAutoProgramBase::ColPositionT WsAutonomousMgr::getColPosition(void)
{
    if(a_lockedIn == true)
    {
        return a_colPosition;
    }
    else
    {
        return a_temp_colPosition;
    }
}

WsAutoProgramBase::PegHeightT WsAutonomousMgr::getPegHeight(void)
{
    if(a_lockedIn == true)
    {
        return a_pegHeight;
    }
    else
    {
        return a_temp_pegHeight;
    }
}


void WsAutonomousMgr::processLockin(void )
{
    float progNumValue = 0;

    float rackValue;
    float colValue;
    float heightValue;



    bool lockInState;
    static bool lockInStatePrev = true;

    progNumValue = ap_inputManager->GetAxisValue(InputManager::AXIS_INDEX_AUTO_PROG_SELECTOR);
    //positionValue = ap_inputManager->GetAxisValue(InputManager::AXIS_INDEX_AUTO_POSITION_SELECTOR);
    rackValue = ap_inputManager->GetAxisValue(InputManager::AXIS_INDEX_AUTO_RACK_SELECTOR);
    colValue = ap_inputManager->GetAxisValue(InputManager::AXIS_INDEX_AUTO_COL_SELECTOR);
    heightValue = ap_inputManager->GetAxisValue(InputManager::AXIS_INDEX_AUTO_HEIGHT_SELECTOR);
    //delayValue = ap_inputManager->GetAxisValue(InputManager::AXIS_INDEX_AUTO_DELAY_SELECTOR);
    lockInState = ap_inputManager->GetButtonValue(InputManager::BUTTON_INDEX_AUTO_LOCKIN);

    //printf("%f %f %f %d\n", progNumValue, positionValue, delayValue, lockInState);

    if(lockInState != lockInStatePrev)
    {
        a_lockedIn = lockInState;
    }


    /* Select the program based on the OI input */
    if((progNumValue >= PROG1_MIN) && 
       (progNumValue <  PROG1_MAX))
    {
        a_tempProgNum = 1;
    }
    else if((progNumValue >= PROG2_MIN) && 
            (progNumValue <  PROG2_MAX))
    {
        a_tempProgNum = 2;
    }
    else if((progNumValue >= PROG3_MIN) && 
            (progNumValue <  PROG3_MAX))
    {
        a_tempProgNum = 3;
    }
    else if((progNumValue >= PROG4_MIN) && 
            (progNumValue <  PROG4_MAX))
    {
        a_tempProgNum = 4;
    }
    else if((progNumValue >= PROG5_MIN) && 
            (progNumValue <  PROG5_MAX))
    {
        a_tempProgNum = 5;
    }
    else if((progNumValue >= PROG6_MIN) && 
            (progNumValue <  PROG6_MAX))
    {
        a_tempProgNum = 6;
    }
    else if((progNumValue >= PROG7_MIN) && 
            (progNumValue <  PROG7_MAX))
    {
        a_tempProgNum = 7;
    }
    else if((progNumValue >= PROG8_MIN) && 
            (progNumValue <  PROG8_MAX))
    {
        a_tempProgNum = 8;
    }
    else if((progNumValue >= PROG9_MIN) && 
            (progNumValue <  PROG9_MAX))
    {
        a_tempProgNum = 9;
    }
#if 0
    else if((progNumValue >= PROG10_MIN) && 
            (progNumValue <  PROG10_MAX))
    {
        a_tempProgNum = 10;
    }
    else if((progNumValue >= PROG11_MIN) && 
            (progNumValue <  PROG11_MAX))
    {
        a_tempProgNum = 11;
    }
#endif
    else
    {
        a_tempProgNum = 1;
    }

    /* Select the start position based on the OI input */
    if((rackValue >= RACK_LEFT_MIN) &&
       (rackValue <= RACK_LEFT_MAX)) // <= because MAX is high voltage
    {
        a_temp_rackPosition = WsAutoProgramBase::RACK_LEFT;
    }
    else if((rackValue >= RACK_RIGHT_MIN) &&
            (rackValue <= RACK_RIGHT_MAX))
    {
        a_temp_rackPosition = WsAutoProgramBase::RACK_RIGHT;
    }
    else
    {
        a_temp_rackPosition = WsAutoProgramBase::RACK_LEFT;
    }



    /* Select the start position based on the OI input */
    if((colValue >= COL_LEFT_MIN) &&
            (colValue <= COL_LEFT_MAX)) // <= because MAX is high voltage
    {
        a_temp_colPosition = WsAutoProgramBase::COL_LEFT;
    }
    else if((colValue >= COL_MID_MIN) &&
            (colValue < COL_MID_MAX))
    {
        a_temp_colPosition = WsAutoProgramBase::COL_MID;
    }
    else if((colValue >= COL_RIGHT_MIN) && // >= because MIN is low voltage
            (colValue < COL_RIGHT_MAX))
    {
        a_temp_colPosition = WsAutoProgramBase::COL_RIGHT;
    }
    else
    {
        a_temp_colPosition = WsAutoProgramBase::COL_RIGHT;
    }

    /* Select the start position based on the OI input */
    if((heightValue >= PEG_LOW_MIN) &&
            (heightValue <= PEG_LOW_MAX)) // <= because MAX is high voltage
    {
        a_temp_pegHeight = WsAutoProgramBase::PEG_LOW;
    }
    else if((heightValue >= PEG_MID_MIN) &&
            (heightValue < PEG_MID_MAX))
    {
        a_temp_pegHeight = WsAutoProgramBase::PEG_MID;
    }
    else if((heightValue >= PEG_HIGH_MIN) && // >= because MIN is low voltage
            (heightValue < PEG_HIGH_MAX))
    {
        a_temp_pegHeight = WsAutoProgramBase::PEG_HIGH;
    }
    else
    {
        a_temp_pegHeight = WsAutoProgramBase::PEG_HIGH;
    }

    switch(a_tempProgNum)
    {
        case 5:
        case 6:
            a_tempDelay = WsAutoProgramBase::DELAY_1;
            break;
        case 7:
        case 8:
            a_tempDelay = WsAutoProgramBase::DELAY_2;
            break;
        default:
            a_tempDelay = WsAutoProgramBase::DELAY_NONE;
            break;
    }

    if(lockInState == a_lockInStateOff)
    {
        a_progNum = 1;
        a_rackPosition = WsAutoProgramBase::RACK_LEFT;
        a_colPosition = WsAutoProgramBase::COL_RIGHT;
        a_pegHeight = WsAutoProgramBase::PEG_HIGH;
        a_delay = WsAutoProgramBase::DELAY_NONE;
    }
    else if((lockInState == a_lockInStateOn) &&
            (lockInStatePrev == a_lockInStateOff))
    {
        a_progNum = a_tempProgNum;
        a_rackPosition = a_temp_rackPosition;
        a_colPosition = a_temp_colPosition;
        a_pegHeight = a_temp_pegHeight;
        a_delay = a_tempDelay;

        if(a_hasRun == true)
        {
            a_hasRun = false;
        }
    }

    if(a_hasRun == true)
    {
        a_lockedIn = false;
    }

    // DEBUG
    //lockInState = true;
    //a_progNum = 2;
    //a_position = START_HOME;

    if(a_lockedIn == true)
    {
        ap_lockInLed->turnOn();
    }
    else
    {
        ap_lockInLed->blinkNumber(a_tempProgNum);
    }

    memset(a_progName, 0, PROG_NAME_LEN);
    if((a_tempProgNum >= 1) || (a_tempProgNum <= MAX_NUM_PROG))
    {
        strncpy(a_progName, progNames[a_temp_rackPosition][a_tempProgNum - 1], PROG_NAME_LEN);
    }
    else
    {
        strncpy(a_progName, "Sleeper", PROG_NAME_LEN);
    }

    lockInStatePrev = lockInState;
}

void WsAutonomousMgr::beginAutonomous(void )
{
    if(a_lockedIn == false)
    {
        a_progNum = 1;
    }

    if(ap_program != NULL)
    {
        ap_program->turnOffDriveBase();
        ap_program->turnOffAppendages();
        delete ap_program;
        ap_program = NULL;
    }

    if(a_hasRun == true)
    {
        ap_program = new WsAutoSleeper();
    }
    else
    {
        switch(a_progNum)
        {
            case 1:
                ap_program = new WsAutoSleeper();
                break;
            case 2:
                // NO DELAY
                ap_program = new WsAutoProgramScoreStraight();
                break;
            case 3:
                // NO DELAY
                ap_program = new WsAutoProgramScoreAngle();
                break;
            case 4:
                // NO DELAY
                // Double
                ap_program = new WsAutoProgramScoreDouble();
                break;
            case 5:
                // DELAY 1
                ap_program = new WsAutoProgramScoreStraight();
                break;
            case 6:
                // DELAY 1
                ap_program = new WsAutoProgramScoreAngle();
                break;
            case 7:
                // DELAY 2
                ap_program = new WsAutoProgramScoreStraight();
                break;
            case 8:
                // DELAY 2
                ap_program = new WsAutoProgramScoreAngle();
                break;
            default:
                ap_program = new WsAutoSleeper();
                break;
        }
    }

    ap_program->setStartDelay(a_delay);
    ap_program->setTargetPeg(a_rackPosition, a_colPosition, a_pegHeight);
    ap_program->assignDriveBase(ap_driveBase);
    ap_program->assignAppendages(ap_larm);

    a_hasRun = true;
    a_autoDone = false;

    ap_program->initParams();

}

bool WsAutonomousMgr::run(void )
{
    bool done = true;

    if(ap_program != NULL)
    {
        done = ap_program->run();
    }

    a_autoDone = done;

    return done;
}

bool WsAutonomousMgr::isDone(void)
{
    return a_autoDone;
}

